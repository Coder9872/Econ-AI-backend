-- Relevance decay + archival job
-- Description: Every day, reduce relevance for all Articles by multiplying by 0.92 and flooring to integer.
-- Any row whose updated relevance < 8 is moved to ArchivedArticles (and removed from Articles).
-- NOTE: Adjust schedule timing (UTC) in the pg_cron section as desired.

-- 1. ArchivedArticles table (only create if not exists).
--    Includes original article id reference (original_id) for traceability.
create table if not exists public."ArchivedArticles" (
  id bigint generated by default as identity primary key,
  original_id bigint,
  archived_at timestamptz not null default now(),
  title text,
  summary text,
  summarized_at timestamptz not null default now(),
  article_date timestamp without time zone,
  link text,
  symbols json,
  relevance integer,
  categories jsonb,
  -- Add any future analytical columns here
  constraint archivedarticles_original_id_fk foreign key (original_id) references public."Articles"(id) on delete set null
);

-- 2. Relevance decay + archival function
create or replace function public.decay_and_archive_articles()
returns void
language plpgsql
as $$
declare
begin
  -- Temporary table to hold rows that will be archived
  create temporary table tmp_to_archive on commit drop as
    select * from public."Articles" where coalesce(relevance,0) < 0; -- start empty

  -- Update relevance scores (multiply by 0.92 and floor)
  update public."Articles"
    set relevance = floor(coalesce(relevance,0) * 0.92)::int
  ;

  -- Collect rows now below threshold (< 8) into temp
  truncate table tmp_to_archive; -- ensure empty
  insert into tmp_to_archive
    select * from public."Articles" where coalesce(relevance,0) < 8;

  -- Insert into ArchivedArticles (mapping original_id)
  insert into public."ArchivedArticles" (original_id, title, summary, article_date, link, symbols, relevance, categories, summarized_at)
    select id, title, summary, article_date, link, symbols, relevance, categories, summarized_at
    from tmp_to_archive;

  -- Delete from Articles
  delete from public."Articles" a
    using tmp_to_archive t
    where a.id = t.id;

  raise notice 'Decay + archive run complete. Archived % rows', (select count(*) from tmp_to_archive);
end;
$$;

-- 3. pg_cron schedule: run daily at 02:15 UTC (choose a quiet period)
-- If pg_cron not enabled, enable in Supabase project settings first.
-- Use cron.schedule to register (idempotent upsert pattern: delete existing then re-add).

-- Remove any prior job with same name (optional safety) - requires pg_cron 1.5+ for job_name
-- For compatibility, we look up by jobname column if available. If not, simply schedule anew.
-- The DO block guards against errors when jobname column absent.

DO $$
BEGIN
  -- Attempt to delete previous job by name (if pg_cron version supports jobname).
  IF EXISTS (select 1 from information_schema.columns where table_schema='cron' and table_name='job' and column_name='jobname') THEN
    perform cron.unschedule(jobid) from cron.job where jobname = 'relevance_decay_daily';
  END IF;
END$$;

-- Schedule new job
select cron.schedule(
  'relevance_decay_daily',      -- job name (if supported)
  '15 2 * * *',                 -- minute hour day month dow (02:15 UTC daily)
  $$select public.decay_and_archive_articles();$$
);

-- To run manually for testing:
-- select public.decay_and_archive_articles();
