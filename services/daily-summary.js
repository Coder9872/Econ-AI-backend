// Daily Summary Generation Service
// Fetches top N articles globally (no date filter) ordered by highest relevance, sends condensed JSON to Gemini,
// parses structured JSON response and stores in DailySummaries table. Uses existing Supabase client and Google GenAI SDK.

const { supabase } = require('../models/supabaseClient');
const { GoogleGenAI } = require('@google/genai');

const DAILY_MODEL = process.env.GEMINI_DAILY_MODEL || 'gemini-2.5-pro';
const MAX_ARTICLES = parseInt(process.env.DAILY_SUMMARY_LIMIT || '150', 10);
const genAI = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

// Ensure DailySummaries table exists (best effort, non-fatal if fails). Call once lazily.
let ensured = false;
async function ensureTable() {
  if (ensured) return;
  const ddl = `create table if not exists public."DailySummaries" (
    id bigint generated by default as identity primary key,
    summary_date date not null unique,
    generated_at timestamptz not null default now(),
    model text,
    overview text,
    what_happened text,
    what_to_expect text,
    key_winners_losers text,
    policy_developments text,
    market_sentiment text,
    economic_releases text,
    sector_performance text,
    raw_json jsonb
  );`;
  try { await supabase.rpc('pg_net', {}); } catch (_) { /* ignore */ }
  // Use a no-op select first to confirm connectivity; then run DDL via a simple insert attempt.
  try {
    await supabase.from('DailySummaries').select('id').limit(1);
  } catch (_) { /* ignore */ }
  // We can't run arbitrary DDL via supabase-js directly unless using a SQL channel / admin; assume table created via migrations.
  ensured = true;
}

function buildPrompt(articles) {
  const trimmed = articles.map(a => ({
    relevance: a.relevance ?? null,
    title: a.title?.slice(0, 260) || '',
    summary: (a.summary || '').replace(/\s+/g, ' ').slice(0, 600)
  }));
  const articlesJson = JSON.stringify(trimmed);
  return `You are an expert financial markets analyst and newsletter author. Given a JSON array of the most relevant recent market news articles (already ranked), produce a comprehensive professional market summary for investors.

OUTPUT STRICTLY AS A SINGLE VALID JSON OBJECT with these keys ONLY:
{
  "overview": string (2-4 concise paragraphs giving holistic narrative),
  "what_happened": string (bullet style: major events & catalysts),
  "what_to_expect": string (forward-looking catalysts, risks, scheduled data),
  "key_winners_losers": string (notable outperformers/underperformers + reasons; tickers if present),
  "policy_developments": string (central bank, fiscal, regulatory, geopolitical),
  "market_sentiment": string (tone, flows, risk appetite),
  "economic_releases": string (macro data prints with figures vs expectations),
  "sector_performance": string (leaders/laggards and drivers)
}

STYLE:
- Objective, data-driven, neutral tone.
- Include key numbers when inferable. Do NOT hallucinate unavailable figures.
- Omit a section only if no meaningful info; otherwise fill it.

RULES (CRITICAL):
- Output MUST be a single valid JSON object. No surrounding markdown fences (no backticks).
- Start with '{' end with '}'. No leading or trailing commentary.
- Do NOT include phrases like 'Here is the JSON'.

ARTICLES_JSON = ${articlesJson}
Return ONLY the JSON object.`;
}

async function fetchTopArticles() {
  // Globally fetch top articles by relevance (no date filter)
  const { data, error } = await supabase
    .from('Articles')
    .select('id,title,summary,relevance')
    .order('relevance', { ascending: false })
    .limit(MAX_ARTICLES);
  if (error) throw error;
  return data || [];
}

function extractJson(text) {
  if (!text) return null;
  // Strip markdown code fences if present
  const stripped = text.replace(/^```(json)?/i, '').replace(/```\s*$/,'').trim();
  // Find first '{' and last '}' to reduce risk of model pre/post chatter
  const first = stripped.indexOf('{');
  const last = stripped.lastIndexOf('}');
  if (first === -1 || last === -1 || last <= first) return null;
  const candidate = stripped.slice(first, last + 1);
  try {
    return JSON.parse(candidate);
  } catch (e) {
    return null;
  }
}

async function generateDailySummary() {
  await ensureTable();
  const today = new Date().toISOString().slice(0,10);
  const existing = await supabase.from('DailySummaries').select('id').eq('summary_date', today).maybeSingle?.();
  if (existing && existing.data && existing.data.id) {
    return { skipped: true, reason: 'already_exists', date: today };
  }
  const articles = await fetchTopArticles();
  if (!articles.length) return { skipped: true, reason: 'no_articles', date: today };
  const prompt = buildPrompt(articles);
  let rawText = '';
  try {
    const resp = await genAI.models.generateContent({ model: DAILY_MODEL, contents: prompt });
    rawText = resp?.text ?? '';
  } catch (e) {
    return { error: 'model_error', message: e.message || String(e) };
  }
  const parsed = extractJson(rawText);
  if (!parsed) {
    return { error: 'parse_failed', note: 'Model output not valid JSON per spec', raw: rawText.slice(0, 700) };
  }
  const insertPayload = {
    summary_date: today,
    model: DAILY_MODEL,
    overview: parsed.overview || null,
    what_happened: parsed.what_happened || null,
    what_to_expect: parsed.what_to_expect || null,
    key_winners_losers: parsed.key_winners_losers || null,
    policy_developments: parsed.policy_developments || null,
    market_sentiment: parsed.market_sentiment || null,
    economic_releases: parsed.economic_releases || null,
    sector_performance: parsed.sector_performance || null,
    raw_json: parsed
  };
  const { error: insErr } = await supabase.from('DailySummaries').insert([insertPayload]);
  if (insErr) return { error: 'insert_failed', message: insErr.message };
  return { date: today, inserted: true };
}

module.exports = { generateDailySummary };
