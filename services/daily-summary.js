// Daily Summary Generation Service
// Fetches top N articles globally (no date filter) ordered by highest relevance, sends condensed JSON to Gemini,
// parses structured JSON response and stores in DailySummaries table. Uses existing Supabase client and Google GenAI SDK.

const { supabase } = require('../models/supabaseClient');
const { GoogleGenAI } = require('@google/genai');

const DAILY_MODEL = process.env.GEMINI_DAILY_MODEL || 'gemini-2.5-pro';
const MAX_ARTICLES = parseInt(process.env.DAILY_SUMMARY_LIMIT || '150', 10);
const genAI = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

// Ensure DailySummaries table exists (best effort, non-fatal if fails). Call once lazily.
let ensured = false;
async function ensureTable() {
  if (ensured) return;
  const ddl = `create table if not exists public."DailySummaries" (
    id bigint generated by default as identity primary key,
    summary_date date not null unique,
    generated_at timestamptz not null default now(),
    model text,
    overview text,
    what_happened text,
    what_to_expect text,
    key_winners_losers text,
    policy_developments text,
    market_sentiment text,
    economic_releases text,
    sector_performance text,
    raw_json jsonb
  );`;
  try { await supabase.rpc('pg_net', {}); } catch (_) { /* ignore */ }
  // Use a no-op select first to confirm connectivity; then run DDL via a simple insert attempt.
  try {
    await supabase.from('DailySummaries').select('id').limit(1);
  } catch (_) { /* ignore */ }
  // We can't run arbitrary DDL via supabase-js directly unless using a SQL channel / admin; assume table created via migrations.
  ensured = true;
}

function buildPrompt(articles) {
  const trimmed = articles.map(a => ({
    relevance: a.relevance ?? null,
    title: a.title?.slice(0, 260) || '',
    summary: (a.summary || '').replace(/\s+/g, ' ').slice(0, 600)
  }));
  const articlesJson = JSON.stringify(trimmed);
  return `You are an expert financial markets analyst and newsletter author. Given a JSON array of the most relevant recent market news articles (already ranked), produce a comprehensive professional market summary for investors.

OUTPUT STRICTLY AS A SINGLE VALID JSON OBJECT with these keys ONLY:
{
  "overview": string,
  "what_happened": string,
  "what_to_expect": string,
  "key_winners_losers": string,
  "policy_developments": string,
  "market_sentiment": string,
  "economic_releases": string,
  "sector_performance": string
}

STYLE (markdown-ready within each string):
- Start each section value with a bolded header like "**Overview:**" then provide content.
- Use "- " bullets for lists; use "**" for emphasis of labels and key numbers.
- Objective, data-driven, neutral tone. Include key numbers when inferable. Do NOT hallucinate.

RULES (CRITICAL):
- Output MUST be a single valid JSON object. No surrounding markdown fences (no backticks).
- Start with '{' end with '}'. No leading or trailing commentary.
- Do NOT include phrases like 'Here is the JSON'.

ARTICLES_JSON = ${articlesJson}
Return ONLY the JSON object.`;
}

async function fetchTopArticles(targetDate) {
  // Fetch top articles by relevance, optionally filtered to a specific date (UTC window)
  const q = supabase
    .from('Articles')
    .select('id,title,summary,relevance')
    .order('relevance', { ascending: false })
    .limit(MAX_ARTICLES);
  if (targetDate) {
    // Constrain to [dateT00:00Z, nextDateT00:00Z)
    const start = new Date(targetDate + 'T00:00:00.000Z');
    if (!Number.isNaN(start.getTime())) {
      const end = new Date(start.getTime() + 24 * 60 * 60 * 1000);
      q.gte('article_date', start.toISOString()).lt('article_date', end.toISOString());
    }
  }
  const { data, error } = await q;
  if (error) throw error;
  return data || [];
}

function extractJson(text) {
  if (!text) return null;
  // Strip markdown code fences if present
  const stripped = text.replace(/^```(json)?/i, '').replace(/```\s*$/,'').trim();
  // Find first '{' and last '}' to reduce risk of model pre/post chatter
  const first = stripped.indexOf('{');
  const last = stripped.lastIndexOf('}');
  if (first === -1 || last === -1 || last <= first) return null;
  const candidate = stripped.slice(first, last + 1);
  try {
    return JSON.parse(candidate);
  } catch (e) {
    return null;
  }
}

function normalizeDate(input) {
  const raw = String(input || '').trim();
  const m = raw.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
  if (!m) return null;
  const [_, y, mo, d] = m; // eslint-disable-line @typescript-eslint/no-unused-vars
  const mm = String(Math.max(1, Math.min(12, parseInt(mo, 10)))).padStart(2, '0');
  const dd = String(Math.max(1, Math.min(31, parseInt(d, 10)))).padStart(2, '0');
  return `${m[1]}-${mm}-${dd}`;
}

async function generateDailySummary(dateArg) {
  await ensureTable();
  const normalized = normalizeDate(dateArg) || new Date().toISOString().slice(0,10);
  const existing = await supabase.from('DailySummaries').select('id').eq('summary_date', normalized).maybeSingle?.();
  if (existing && existing.data && existing.data.id) {
    return { skipped: true, reason: 'already_exists', date: normalized };
  }
  const articles = await fetchTopArticles(normalized);
  if (!articles.length) return { skipped: true, reason: 'no_articles', date: normalized };
  const prompt = buildPrompt(articles);
  let rawText = '';
  try {
    const resp = await genAI.models.generateContent({ model: DAILY_MODEL, contents: prompt });
    rawText = resp?.text ?? '';
  } catch (e) {
    return { error: 'model_error', message: e.message || String(e) };
  }
  const parsed = extractJson(rawText);
  if (!parsed) {
    return { error: 'parse_failed', note: 'Model output not valid JSON per spec', raw: rawText.slice(0, 700) };
  }
  const insertPayload = {
    summary_date: normalized,
    model: DAILY_MODEL,
    overview: parsed.overview || null,
    what_happened: parsed.what_happened || null,
    what_to_expect: parsed.what_to_expect || null,
    key_winners_losers: parsed.key_winners_losers || null,
    policy_developments: parsed.policy_developments || null,
    market_sentiment: parsed.market_sentiment || null,
    economic_releases: parsed.economic_releases || null,
    sector_performance: parsed.sector_performance || null,
    raw_json: parsed
  };
  const { error: insErr } = await supabase.from('DailySummaries').insert([insertPayload]);
  if (insErr) return { error: 'insert_failed', message: insErr.message };
  return { date: normalized, inserted: true };
}

module.exports = { generateDailySummary };
